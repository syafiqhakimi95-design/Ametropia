<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tri-Action Optics Simulator</title>
    <style>
        :root {
            --bg: #f8fafc;
            --panel: #ffffff;
            --accent: #2563eb;
            --text: #334155;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- LAYOUT GRID --- */
        .main-stage {
            flex: 1;
            display: flex;
            padding: 10px;
            gap: 10px;
            min-height: 0;
        }

        /* The Simulation Box */
        .visual-container {
            flex: 1;
            background: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Right Sidebar (Accommodation) */
        .acc-sidebar {
            width: 70px;
            background: #fff;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .acc-track {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 10px 0;
        }

        /* Vertical Slider */
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* Webkit */
            width: 8px;
            height: 100%;
            cursor: ns-resize;
        }

        /* Bottom Controls (Object & Settings) */
        .controls-deck {
            background: #fff;
            border-top: 1px solid #cbd5e1;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
            z-index: 10;
        }

        .settings-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #94a3b8;
            border-radius: 6px;
            font-size: 0.95rem;
            flex: 1;
            background: #fff;
        }

        .age-box {
            display: flex;
            align-items: center;
            background: #f1f5f9;
            padding: 5px 12px;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
        }
        
        .age-box input {
            background: transparent;
            border: none;
            width: 40px;
            text-align: center;
            font-weight: bold;
            font-size: 1rem;
        }

        /* Horizontal Slider (Object) */
        .object-control {
            width: 100%;
        }
        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        input[type=range].h-slider {
            width: 100%;
            cursor: ew-resize;
        }

        /* Floating Badge */
        .status-badge {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 12px;
            border-radius: 6px;
            border-left: 4px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.85rem;
            line-height: 1.4;
        }
        .status-badge b { display: block; font-size: 1rem; }

    </style>
</head>
<body>

    <div class="main-stage">
        
        <div class="visual-container">
            <canvas id="simCanvas"></canvas>
            <div id="statusBadge" class="status-badge">
                <b id="statusTitle">CLEAR</b>
                <span id="statusDesc">Infinity</span>
            </div>
        </div>

        <div class="acc-sidebar">
            <span style="font-size:0.7rem; font-weight:bold; color:#64748b; text-align:center;">LENS<br>POWER</span>
            <div class="acc-track">
                <input type="range" id="accSlider" orient="vertical" min="0" max="15" step="0.1" value="0">
            </div>
            <span id="accDisplay" style="font-size:0.8rem; font-weight:bold; color:#2563eb;">0.0 D</span>
        </div>

    </div>

    <div class="controls-deck">
        
        <div class="settings-row">
            <select id="conditionSelect">
                <option value="emmetropia">1. Emmetropia (Normal)</option>
                <option value="myopia">2. Myopia (-2.50 D)</option>
                <option value="hyperopia">3. Hyperopia (+2.50 D)</option>
                <option value="presbyopia">4. Presbyopia (Emmetropia Base)</option>
            </select>
            
            <div class="age-box">
                <label for="ageInput" style="font-size:0.85rem; margin-right:5px;">Age:</label>
                <input type="number" id="ageInput" value="20" min="10" max="80">
            </div>
        </div>

        <div class="object-control">
            <div class="slider-header">
                <span>Move Object (Apple) üçé</span>
                <span id="distDisplay">Infinity</span>
            </div>
            <input type="range" id="distSlider" class="h-slider" min="0" max="100" step="0.5" value="100">
        </div>

    </div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    // UI Refs
    const ui = {
        accSlider: document.getElementById('accSlider'),
        distSlider: document.getElementById('distSlider'),
        condSelect: document.getElementById('conditionSelect'),
        ageInput: document.getElementById('ageInput'),
        
        accDisplay: document.getElementById('accDisplay'),
        distDisplay: document.getElementById('distDisplay'),
        statusTitle: document.getElementById('statusTitle'),
        statusDesc: document.getElementById('statusDesc'),
        badge: document.getElementById('statusBadge')
    };

    // Physics State
    let state = {
        condition: 'emmetropia',
        age: 20,
        maxAmp: 12.5,
        refError: 0,      // -2.50 (Myopia), +2.50 (Hyperopia)
        
        currentAcc: 0,    // The actual power the lens is exerting
        currentDistD: 0,  // The actual distance of the object in Diopters (0 = Infinity)
        isBlurred: false
    };

    // --- LOGIC ENGINE ---

    function calculateMaxAmp() {
        // Hofstetter's: 18.5 - 0.3 * Age
        let val = 18.5 - (0.3 * parseInt(ui.ageInput.value));
        return Math.max(0, val);
    }

    function updateStateFromInputs() {
        state.condition = ui.condSelect.value;
        state.age = parseInt(ui.ageInput.value);
        state.maxAmp = calculateMaxAmp();

        if (state.condition === 'emmetropia' || state.condition === 'presbyopia') state.refError = 0;
        if (state.condition === 'myopia') state.refError = -2.50;   // Needs -2.50 correction
        if (state.condition === 'hyperopia') state.refError = 2.50; // Needs +2.50 correction
    }

    // TRIGGER 1: Moving the Object (Apple)
    function onObjectMove() {
        updateStateFromInputs();

        // 1. Get Demand from Slider (0-100 -> 10D-0D)
        let sliderVal = parseFloat(ui.distSlider.value);
        let demand = (100 - sliderVal) / 10; // 0 = Infinity, 10 = 10cm
        state.currentDistD = demand;

        // 2. Calculate Required Accommodation
        // Needed = Demand + RefractiveError
        // E.g. Hyperope (Error +2.5) looking at Infinity (0): Needed = 2.5
        // E.g. Myope (Error -2.5) looking at 40cm (2.5): Needed = 2.5 + (-2.5) = 0
        let needed = demand + state.refError;
        if (needed < 0) needed = 0; // Lens can't be negative power

        // 3. Apply Max Amplitude Limit
        if (needed > state.maxAmp) {
            state.currentAcc = state.maxAmp;
            state.isBlurred = true;
        } else {
            state.currentAcc = needed;
            state.isBlurred = false;
        }

        // 4. Update Acc Slider & Visuals
        ui.accSlider.value = state.currentAcc;
        updateVisuals();
    }

    // TRIGGER 2: Moving the Accommodation Slider
    function onAccMove() {
        updateStateFromInputs();

        // 1. Get Acc Effort
        let effort = parseFloat(ui.accSlider.value);
        state.currentAcc = effort;

        // 2. Check if Effort exceeds Max Amp (Physiological limit)
        // If user drags past limit, we treat it as max effort but physical limit applies
        // Or we allow it but show blur? Let's stick to "Lens matches slider" logic for clarity
        // But mark it red if impossible?
        // Let's assume the slider IS the lens shape.
        
        let effectiveAcc = state.currentAcc;
        if (effectiveAcc > state.maxAmp) state.isBlurred = true; 
        else state.isBlurred = false; // Temporarily reset, check distance match later

        // 3. Calculate Focal Distance
        // Where *is* the clear point for this Acc?
        // ClearPoint = Acc - RefError
        let clearD = effectiveAcc - state.refError;
        if (clearD < 0) clearD = 0; // Virtual far point (Hyperopia) -> clamp to Infinity for object

        state.currentDistD = clearD;

        // 4. Update Object Slider
        // Convert D back to 0-100
        let newSliderVal = 100 - (state.currentDistD * 10);
        // Clamp
        if (newSliderVal < 0) newSliderVal = 0;
        if (newSliderVal > 100) newSliderVal = 100;
        ui.distSlider.value = newSliderVal;

        updateVisuals();
    }

    function updateVisuals() {
        // Text Updates
        ui.accDisplay.innerText = state.currentAcc.toFixed(2) + " D";
        
        if (state.currentDistD <= 0.05) ui.distDisplay.innerText = "Infinity";
        else ui.distDisplay.innerText = (100/state.currentDistD).toFixed(0) + " cm";

        // Status Badge
        if (state.isBlurred) {
            ui.statusTitle.innerText = "BLUR";
            ui.statusTitle.style.color = "#ef4444";
            ui.badge.style.borderLeftColor = "#ef4444";
            
            // Helpful context
            if (state.currentAcc >= state.maxAmp) ui.statusDesc.innerText = "Max Amp Reached";
            else ui.statusDesc.innerText = "Out of Focus";
        } else {
            ui.statusTitle.innerText = "CLEAR";
            ui.statusTitle.style.color = "#22c55e";
            ui.badge.style.borderLeftColor = "#22c55e";
            ui.statusDesc.innerText = "Image on Retina";
        }

        draw();
    }

    // --- DRAWING ENGINE (Tri-Action Visuals) ---
    function draw() {
        // 1. Setup Canvas
        // Handle pixel density for crisp lines
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width;
        const h = rect.height;

        ctx.clearRect(0, 0, w, h);

        const cy = h / 2;
        const cx = w * 0.75; // Eye Center (Right side)
        const eyeRadius = 60;

        // --- DRAW ANATOMICAL EYE ---
        
        // A. Sclera (White Ball)
        ctx.beginPath();
        ctx.arc(cx, cy, eyeRadius, 0, Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        // B. Cornea (Anterior Bulge)
        ctx.beginPath();
        ctx.arc(cx - 55, cy, 25, 1.5, 4.7); // Simple arc bump
        // Fill cornea area
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.fill();
        ctx.stroke();

        // C. Iris (Vertical aperture lines)
        ctx.beginPath();
        ctx.moveTo(cx - 50, cy - 25);
        ctx.lineTo(cx - 50, cy - 15);
        ctx.moveTo(cx - 50, cy + 25);
        ctx.lineTo(cx - 50, cy + 15);
        ctx.strokeStyle = "brown";
        ctx.lineWidth = 4;
        ctx.stroke();

        // D. CRYSTALLINE LENS (Inside the eye)
        // Logic: Positioned BEHIND iris (x approx cx-40)
        // Thickness: Base 6px + (Acc * 1.2)
        // Max thickness visual cap ~25px
        let lensThick = 6 + (state.currentAcc * 1.5);
        let lensHeight = 35;
        let lensX = cx - 40; 

        ctx.beginPath();
        ctx.ellipse(lensX, cy, lensThick, lensHeight, 0, 0, Math.PI*2);
        ctx.fillStyle = "#bae6fd"; // Blue tint
        ctx.fill();
        ctx.strokeStyle = "#0284c7";
        ctx.lineWidth = 2;
        ctx.stroke();

        // --- DRAW OBJECT (Apple) ---
        
        // Map 0-100 slider to Screen X coordinates
        // 100 (Infinity) -> x = 20
        // 0 (Close) -> x = cx - 120 (Near point visual limit)
        let sliderVal = parseFloat(ui.distSlider.value);
        let normVal = sliderVal / 100; // 0 to 1
        
        let startX = cx - 140; 
        let endX = 30;
        let objX = startX - (normVal * (startX - endX));

        // Draw Object Apple üçé
        ctx.font = "30px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üçé", objX, cy);

        // --- DRAW RAYS ---
        // Path: Object -> Cornea Surface -> Lens Center -> Retina
        
        let corneaX = cx - 60;
        let retinaX = cx + eyeRadius; // Back of eye

        ctx.strokeStyle = "orange";
        ctx.lineWidth = 1.5;
        ctx.beginPath();

        // 1. Top Ray
        ctx.moveTo(objX + 10, cy - 10);
        ctx.lineTo(corneaX, cy - 15); // Hit Cornea
        ctx.lineTo(lensX, cy - 20);   // Refract to Lens Top
        
        // 2. Bottom Ray
        ctx.moveTo(objX + 10, cy + 10);
        ctx.lineTo(corneaX, cy + 15);
        ctx.lineTo(lensX, cy + 20);

        ctx.stroke();

        // --- DRAW RETINAL IMAGE ---
        
        // Rays from Lens to Retina
        // If Blurred: Rays don't meet at retina
        // If Clear: Rays meet at retina
        
        let focusPointX = retinaX;
        let imgAlpha = 1.0;
        
        if (state.isBlurred) {
            // Check direction of blur
            // If Myopia (or Obj too close): Focus is BEFORE retina
            // If Hyperopia (or Obj too far): Focus is BEHIND retina
            
            // Simple visual heuristic:
            // Needed Acc vs Actual Acc
            let needed = state.currentDistD + state.refError;
            if (needed < 0) needed = 0;
            
            if (state.currentAcc < needed) {
                // Undercorrected -> Focus BEHIND retina (Hyperopic blur)
                focusPointX = retinaX + 40;
            } else if (state.currentAcc > needed) {
                // Overcorrected -> Focus BEFORE retina (Myopic blur)
                focusPointX = retinaX - 30;
            }
            imgAlpha = 0.4; // Ghosting effect
        }

        // Draw Blue Refracted Rays
        ctx.strokeStyle = "#2563eb";
        ctx.beginPath();
        // Top ray to focus
        ctx.moveTo(lensX, cy - 20);
        ctx.lineTo(focusPointX, cy + 10); // Inverting
        // Bottom ray to focus
        ctx.moveTo(lensX, cy + 20);
        ctx.lineTo(focusPointX, cy - 10);
        ctx.stroke();

        // Draw Image Apple üçè
        // Positioned ON the retina regardless of focus point (it's the screen)
        // But if blurred, it looks fuzzy
        ctx.globalAlpha = imgAlpha;
        ctx.save();
        ctx.translate(retinaX, cy);
        ctx.rotate(Math.PI); // Invert
        ctx.font = "18px sans-serif";
        
        if (state.isBlurred) {
            // Draw double apple for blur
            ctx.fillText("üçè", -2, -2);
            ctx.fillText("üçè", 2, 2);
        } else {
            ctx.fillText("üçè", 0, 0);
        }
        
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }

    // --- EVENTS ---
    ui.distSlider.addEventListener('input', onObjectMove);
    ui.accSlider.addEventListener('input', onAccMove);
    ui.condSelect.addEventListener('change', () => { 
        updateStateFromInputs(); 
        onObjectMove(); // Recalculate based on new condition
    });
    ui.ageInput.addEventListener('input', () => { 
        updateStateFromInputs(); 
        onObjectMove(); 
    });
    
    // Window Resize
    window.addEventListener('resize', draw);

    // Initialize
    updateStateFromInputs();
    onObjectMove(); // Start with object based calculation

</script>
</body>
</html>

